---
title: "Spring JPA1"
layout: single
categories: spring
tags: spring
toc: true
toc_label: "Spring JPA1" 
---

# Spring JPA1

멋쟁이사자처럼 대학 11기 백엔드 스프링부트 교육 과정 중 인프런 `실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발`을 수강하고 정리한 포스트입니다.

## 1. 프로젝트 환경설정

### 프로젝트 생성

Spring Initializr [(https://start.spring.io)](https://start.spring.io) 를 이용한 프로젝트 생성

- Project: Gradle
- Language: Java
- Spring Boot: 3.0.6 (안정화)
- Group: jpabook
- Artifact: jpashop
- Dependencies: 
	- Spring Web Starter
	- Thymeleaf
	- Spring Data JPA
	- H2 Database
	- Lombok

\* Lombok: getter, setter 등을 어노테이션으로 만들어주는 라이브러리

**build.gradle**

```gradle
plugins {
	id 'java'
	// 스프링부트 플러그인은 라이브러리들에 대한 디펜던시 버전 관리를 해줌
	id 'org.springframework.boot' version '3.0.6'
	id 'io.spring.dependency-management' version '1.1.0'
}

group = 'jpabook'
version = '0.0.1-SNAPSHOT'
// 자바 버전
sourceCompatibility = '17'

configurations {
	compileOnly {
		// 롬복
		extendsFrom annotationProcessor
	}
}

// 라이브러리를 받는 공간
repositories {
	mavenCentral()
}

// 그래들은 기본적으로 의존관계가 필요한 라이브러리들을 전부 연결하여 가져옴
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
	implementation 'org.springframework.boot:spring-boot-starter-validation'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	compileOnly 'org.projectlombok:lombok'
	runtimeOnly 'com.h2database:h2'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	//JUnit4 추가
	testImplementation("org.junit.vintage:junit-vintage-engine") {
		exclude group: "org.hamcrest", module: "hamcrest-core"
	}
}

tasks.named('test') {
	useJUnitPlatform()
}
```

**JpashopApplication & JpashopApplicationTest**

Spring Initializr가 기본적으로 만들어주는 클래스  

```java
@SpringBootApplication
public class JpashopApplication {
	public static void main(String[] args) {
		SpringApplication.run(JpashopApplication.class, args);
	}
}
```
```java
@SpringBootTest
class JpashopApplicationTests {
	@Test
	void contextLoads() {
	}
}
```

**롬복 플러그인 설치**

![image](https://user-images.githubusercontent.com/82245973/236116926-fc87d06e-c679-4615-92a4-80933ac39f52.png)  

File > Settings > Plugins > Marketplace > Lombok 검색 후 설치  

**롬복 사용 설정**

![image](https://user-images.githubusercontent.com/82245973/236116372-e8dd0acf-d9e8-47a7-be2f-ba1fe40eec0b.png)  

File > Settings > Build, Execution, Deployment > Compiler > Annotation Processors > Enable annotation processing 체크

### 라이브러리 살펴보기

**명령어로 보기**

```
./gradlew dependencies —configuration compileClasspath
```
의존관계를 트리형태로 보여준다.

**IntelliJ로 보기**

![image](https://user-images.githubusercontent.com/82245973/236123179-ee71ad85-aef9-4598-ac4f-716cab120e8b.png)

- `spring-boot-starter-web` → `spring-boot-starter-tomcat` / `spring-webmvc`

- `spring-boot-starter-thymeleaf`

- `spring-boot-starter-data-jpa` → `spring-boot-starter-aop` / `spring-boot-starter-jdbc` / `hibernate` / `spring-data-jpa`
	- `spring-boot-starter-jdbc` → `HikariCP 커넥션 풀`  
		스프링부트 2.0부터 커넥션 풀로 HikariCP를 기본으로 사용한다.  
    
- (공통) `spring-boot-starter` → `spring-boot-starter-logging` / `spring-boot`
	- `spring-boot-starter-logging` → `logback` / `slf4j`  
		slf4j는 로그를 찍는 인터페이스의 모음으로	구현체로 logback을 기본으로 사용한다.  
	- `spring-boot` → `spring-core`

- `spring-boot-starter-test` → `junit` / `mockito` / `assertj` / `spring-test`

### View 환경 설정

템플릿 엔진으로는 Thymeleaf, Apache Freemarker, Mustache, Groovy Templates 등이 있는데 스프링은 Thymeleaf를 밀고 있는 추세이다.  

Thymeleaf는 Natural templates로 HTML 태그안에 문법을 넣어 문제를 해결하여 markup을 깨지않아 웹브라우저에서 열 수 있다.

\* 스프링을 공부할 때, [https://spring.io/guides](https://spring.io/guides) 에서 가이드를 참고하면서 공부하면 좋다.

**HelloController.java**

```java
@Controller
public class HelloController {
    @GetMapping("hello")
    // Model에 데이터를 실어서 Controller에서 Model을 View에 넘김
    public String hello(Model model){
        // name이라는 키로 value값을 넘김
        model.addAttribute("data", "hello");
        // viewName(html 파일 이름) 리턴
        // 스프링부트의 타임리프가 /resources/templates/ 에서 {viewName}.html을 매핑해줌
        return "hello";
    }
}
```

**hello.html**

```html
<!DOCTYPE HTML>
<!-- html 태그에 namespace를 thymeleaf로 설정 -->
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Hello</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
	<!-- Model로 넘긴 데이터의 키로 값에 접근해 출력 -->
	<!-- p 태그 안 텍스트는 기본 값 (thymeleaf를 거치지 않음) -->
	<p th:text="'안녕하세요. ' + ${data}" >안녕하세요. 손님</p>
</body>
</html>
```

**Server Side Rendering**

![image](https://user-images.githubusercontent.com/82245973/236130885-d0daf09d-ec46-4d4f-8dd5-9d9ec484dce2.png)  

**Static Contents**

![image](https://user-images.githubusercontent.com/82245973/236131957-43b2d1ae-52dd-4340-a231-366906d045e8.png)  

resoreces 파일이 변경되면 서버를 재시작해야 한다.  

\* html 파일 변경후 recompile해도 화면이 바뀌지 않는다.  
build.gradle에 `devtools` 라이브러리를 추가하면 html 파일만 리컴파일 해주면 변경된 화면을 볼 수 있다.

```gradle
// devtools: 개발할 때 유용한 기능들이 많은 라이브러리(캐쉬, 리로딩 등)
implementation 'org.springframework.boot:spring-boot-devtools'
```

### H2 데이터베이스 설치

H2 데이터베이스는 개발이나 테스트 용도로 가볍고 편리하며 웹 콘솔 환경을 제공한다.  

[https://www.h2database.com/html/download-archive.html](https://www.h2database.com/html/download-archive.html) 에서 1.4.200 버전을 다운로드 한다.

\* 자바 17버전 사용시 h2 2.1.214 버전을 설치하는 것을 추천한다. 알 수 없는 오류로 몇 시간을 버렸다...

다운로드 후 `C:\Program Files (x86)\H2\bin\h2.bat`를 실행하면 웹 콘솔 환경(java)이 실행된다.

![image](https://user-images.githubusercontent.com/82245973/236138463-0f2067f0-5b00-4f06-9e18-12344fb977d1.png)  

JDBC URL에 db파일이 저장될 위치(파일 모드)를 지정하고 로그인한다.  

![image](https://user-images.githubusercontent.com/82245973/236139468-68a8d5cd-2b32-4ef6-b599-9528c7e6a318.png)  

사용자 폴더 밑에 `jpashop.mv.db`가 생성되고 화면은 다음과 같다.   

![image](https://user-images.githubusercontent.com/82245973/236138886-c4d622c7-d6a7-4ffa-975c-4f86bf639e8f.png)  

연결 끊고 난 후 다음부터 접근할 때에는 JDBC URL을 `jdbc:h2:tcp://localhost/~/jpashop`(네트워크 모드)로 설정하고 로그인한다.

### JPA와 DB 설정, 동작확인

application.properties를 지우고 application.yml을 생성한다.  
설정파일이 많아지고 복잡해질수록 yml이 편리하다.

**application.yml**

```yml
spring:
  # 데이터베이스 커넥션과 관련된 데이터 소스 설정
  # Hikari CP를 사용해서 커넥션 풀 등을 스프링부트가 알아서 세팅해줌
  datasource:
    # 데이터베이스 접근 url
    # MVCC: 여러 명이 한번에 접근했을 때 좀 더 빨리 처리됨;MVCC=TRUE
    url: jdbc:h2:tcp://localhost/~/jpashop
    username: sa
    password:
    driver-class-name: org.h2.Driver
  # jpa 설정
  # 스프링부트 메뉴얼에서 설정법 확인 가능
  jpa:
    hibernate:
      # create: 애플리케이션 실행 시점에 테이블을 지우고 다시 생성
      ddl-auto: create
    properties:
      hibernate:
        # show_sql: true, System.out에 출력
        format_sql: true

# 로깅 설정
logging:
  # 로그 레벨 설정
  level:
    # debug 모드 시 hibernate가 남기는 모든 sql을 볼 수 있음
    # 로거를 통해 출력
    org.hibernate.SQL: debug
    # 쿼리 파라미터 로그 남기기
    org.hibernate.orm.jdbc.bind: trace #스프링 부트 3.x, hibernate6
```

**회원 엔티티**

```java
@Entity
// Lombok: getter와 setter 메서드를 만들어 줌
@Getter
@Setter
public class Member {
    @Id
    @GeneratedValue
    private Long id;
    private String username;
}
```

**회원 리포지토리**

```java
@Repository
public class MemberRepository {

    // @PersistenceContext: 스프링부트가 EntityManager를 자동으로 주입해줌
    // spring-data-jpa 라이브러리를 추가하면 자동으로 스프링 빈에 엔티티매니저를 등록
    @PersistenceContext
    private EntityManager em;

    // 커맨드와 쿼리 분리 원칙 -> 저장을 하고나면 가급적이면 사이드 이펙트 효과 때문에 리턴값을 거의 안 만들고 id값으로 조회하기 위해 id값을 리턴함
    public Long save(Member member){
        em.persist(member);
        return member.getId();
    }

    public Member find(Long id){
        return em.find(Member.class, id);
    }
}
```

**테스트**

File > Settings > Editor > Live Templates 에서 커스텀 템플릿을 만들어 사용할 수 있다.

![image](https://user-images.githubusercontent.com/82245973/236148965-9f4c6232-8f03-4fd2-a000-c1173d5a3fd6.png)

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class MemberRepositoryTest {
    @Autowired
    MemberRepository memberRepository;

    @Test
    // @Transactional: EntityManager를 통한 모든 데이터 변경은 항상 트랜잭션 안에서 이루어져야 함
    // 이 어노테이션이 없으면 오류 발생, 테스트 케이스에 있으면 테스트가 끝나고 롤백
    @Transactional
    // 롤백을 실행하지 않음
    @Rollback(false)
    public void testMember() throws Exception{
        // given
        Member member = new Member();
        member.setUsername("memberA");

        // when
        Long savedId = memberRepository.save(member);
        Member findMember = memberRepository.find(savedId);

        // then
        Assertions.assertThat(findMember.getId()).isEqualTo(member.getId());
        Assertions.assertThat(findMember.getUsername()).isEqualTo(member.getUsername());
        // 영속성 컨텍스트 안에서 id값이 같으면 같은 엔티티로 식별
        Assertions.assertThat(findMember).isEqualTo(member);
    }
}
```

**jar 빌드해서 동작 확인**

```
gradlew clean build // 지우고 재빌드
cd build/libs   // jar 파일이 있는 폴더로 이동
java -jar jpashop-0.0.1-SNAPSHOT.jar // jar 파일 실행
```

**외부 라이브러리 - 쿼리 파라미터 로그 남기기**

우선 build.gradle에 다음 라이브러리를 추가한다. [https://github.com/gavlyukovskiy/spring-boot-data-source-decorator](https://github.com/gavlyukovskiy/spring-boot-data-source-decorator)  

```gradle
// 쿼리 파라미터 로그 외부 라이브러리
implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.8.0'
```

`src/resources/META-INF/spring/` 폴더에 `org.springframework.boot.autoconfigure.AutoConfiguration.imports` 파일을 만들고 다음과 같이 저장한다.

```
com.github.gavlyukovskiy.boot.jdbc.decorator.DataSourceDecoratorAutoConfiguration
```

`src/resources/` 폴더에 `spy.properties` 파일을 만들고 다음과 같이 저장한다.

```
appender=com.p6spy.engine.spy.appender.Slf4JLogger
```

그러면 다음과 같은 쿼리 파리미터 로그를 볼 수 있다.

```
|statement|connection 4|url jdbc:h2:tcp://localhost/~/jpashop
|insert into member (username, id) values (?, ?)
|insert into member (username, id) values ('memberA', 1)
```

이런 라이브러리들은 개발단계에서 편의성 용도로 사용하고 실제 운영시 성능 저하 우려가 있어서 성능 테스트를 해보고 사용해야 한다.

## 2. 도메인 분석 설계

### 요구사항 분석

![image](https://user-images.githubusercontent.com/82245973/236359950-9f9369e0-02ae-494f-8749-4f3e05b90fc4.png)

간단한 쇼핑몰 요구사항

- 회원 기능
  - 회원 등록, 회원 조회
- 상품 기능
  - 상품 등록, 상품 수정, 상품 조회
- 주문 기능
  - 상품 주문, 주문 내역 조회, 주문 취소
- 기타 요구사항
  - 상품은 재고 관리가 필요하다. 
  - 상품의 종류는 도서, 음반, 영화가 있다.
  - 상품을 카테고리로 구분할 수 있다.
  - 상품 주문시 배송 정보를 입력할 수 있다.

### 도메인 모델과 테이블 설계

![image](https://user-images.githubusercontent.com/82245973/236360788-f5fa6914-1a04-4e28-8e69-9e16456d697d.png)

- 회원-주문
  - 회원은 여러 상품을 주문할 수 있다 → 일대다 관계  
- 주문-상품
    - 회원은 주문할 때 여러 상품을 주문할 수 있고, 상품도 여러 주문에 담길 수 있다 →  다대다 관계  
    - 주문과 상품의 다대다 관계를 주문상품을 통해서 일대다, 다대일 관계로 풀어낸다.  
      - 주문-주문상품
        - 회원은 주문할때 여러 상품을 주문할 수 있다 → 일대다 관계  
      - 상품-주문상품
        - 상품도 여러 주문에 담길 수 있다 →  다대일 관계  
- 주문-배송
  - 한번 주문을 할 때 배송정보를 하나 입력한다 → 일대일 관계  
- 카테고리-상품
  - 상품은 도서, 음반, 영화 타입으로 나눠질 수 있다 → 상속관계
  - 하나의 카테고리에 여러 상품이 들어갈 수 있고 하나의 상품이 여러 카테고리에 들어갈 수 있다 → 다대다 관계  

**회원 엔티티 분석**

![image](https://user-images.githubusercontent.com/82245973/236360810-92603204-b9eb-4473-899a-f88bd031ac6f.png)

- Member
  - 공통 속성: id (pk, long)
  - name: 이름
  - address: 주소, 임베디드 타입 (내장 타입, 값 타입)
  - orders: 주문 리스트
- Order
  - member: 회원
  - orderItem: 주문상품 리스트
  - delivery: 배송정보
  - orderDate: 주문날짜
  - status: 주문상태 (주문, 취소)
- OrderItem
  - orderPrice: 주문 금액
  - count: 주문 수량
- Delivary:
  - order: 주문
  - address: 배송지 주소
  - status: 배송상태
- Item:
  - name: 이름
  - price: 가격
  - stockQuantity: 재고
  - categories: 포함 카테고리
- Category
  - Album
    - artist: 아티스트
    - etc: 기타
  - Book
    - author: 저자
    - isbn: isbn
  - Movie
    - director: 감독
    - actor: 배우
  - parent: 부모 카테고리
  - child: 자식
  - items: 상품 리스트

\* 카테고리-상품의 다대다 관계는 실무에서 쓰면 안 된다 → 일대다, 다대일 관계로 풀어내야한다  

\* 회원-주문의 양방향 연관관계는 가능하면 쓰지말고 단방향 연관관계를 쓰는게 좋다.  

\* 회원과 주문은 동급으로 봐야한다. '회원을 통해서 항상 주문이 일어난다'가 아니라 '주문을 생성할 때 회원이 필요하다'라고 생각하자. 
쿼리에서도 회원의 주문내역을 찾는게 아니라 주문에서 필터링 조건에 회원이 들어가게 된다.  

**회원 테이블 분석**

![image](https://user-images.githubusercontent.com/82245973/236360820-2b82138a-26af-43a2-a7af-8b8d509d668e.png)

- member: address(값 타입, 임베디드 타입) 정보를 내려받는다.
- delivery: member와 같이 address(값 타입, 임베디드 타입) 정보를 내려받는다.
- item: 상속 관계 매핑의 3가지 방법 중 싱글 테이블 전략을 이용한다.
  - 싱글 테이블 전략: 모든 엔티티를 포함하는 테이블을 만들고 dtype으로 구분한다.
- orders: member_id(fk), delivery_id(fk)를 가진다.
- orderItem: order_id(fk)를 가진다.
- category_item: 관계형 데이터베이스는 다대다 관계를 표현할 수 없어서 중간에 매핑 테이블을 두고 다대다 관계를 일대다, 다대일 관계로 풀어낸다.

**연관관계 매핑 분석 및 연관관계 주인 설정**

- 회원-주문: 일대다, 다대일 양방향 관계, member_id를 가진주문이 연관관계 주인
- 주문상품-주문: 다대일 양방향 관계, order_id를 가진 주문상품이 연관관계 주인
- 주문상품-상품: 다대일 단방향 관계, item_id를 가진 주문상품이 연관관계 주인
- 주문-배송: 일대일 단방향 관계, delivery_id를 가진 주문이 연관관계 주인
- 카테고리-상품: 다대다 관계

\* 외래키가 있는 곳을 연관관계의 주인으로 정하는 것이 좋다.

### 엔티티 클래스 개발

\* 실무에서는 가급적이면 getter만 사용하고 setter는 꼭 필요한 경우에만 사용한다.

**회원 엔티티**
```java
@Entity
@Getter
@Setter
public class Member {
    @Id
    @GeneratedValue
    // 컬럼명 설정
    @Column(name = "member_id")
    private Long id;

    private String name;

    // @Embedded: 내장 타입을 포함함
    @Embedded
    private Address address;

    // 일대다 관계
    // 양방향 연관관계, order 테이블에 있는 member 필드에 의해서 매핑됨
    @OneToMany(mappedBy = "member")
    private List<Order> orders = new ArrayList<>();
}
```

**주문 엔티티**
```java
@Entity
// 테이블명 설정
// sql의 order by 절과 겹쳐서 orders로 변경
@Table(name = "orders")
@Getter
@Setter
public class Order {
    @Id
    @GeneratedValue
    @Column(name = "order_id")
    private Long id;

    // 다대일 관계, 지연로딩 설정
    @ManyToOne(fetch = FetchType.LAZY)
    // 외래키 설정, 연관관계 주인
    @JoinColumn(name = "member_id")
    private Member member;

    // 일대다 관계
    // CascadeType.ALL: 컬렉션에 persist를 전파(부모와 같이 진행)
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
    private List<OrderItem> orderItems = new ArrayList<>();

    // 일대일 관계, 지연로딩 설정
    // CascadeType.ALL: 각각 진행하는 persist를 같이 진행하게 해줌
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    // 외래키 설정, 연관관계 주인
    // Delivery 보다 Order에서 접근을 더 많이 함
    @JoinColumn(name = "delivery_id")
    private Delivery delivery;

    // 주문시간
    private LocalDateTime orderDate;

    // EumType.STRING: Enum 타입 값을 문자열로 지정
    @Enumerated(EnumType.STRING)
    // 주문상태 (ORDER, CANCEL)
    private OrderStatus status;

    // 연관관계 편의 메서드
    // 양방향 연관관계 설정을 원자적으로 묶는 메서드
    public void setMember(Member member) {
        this.member = member;
        member.getOrders().add(this);
    }

    public void addOrderItem(OrderItem orderItem) {
        orderItems.add(orderItem);
        orderItem.setOrder(this);
    }

    public void setDelivery(Delivery delivery) {
        this.delivery = delivery;
        delivery.setOrder(this);
    }
}
```

**주문상태**
```java
public enum OrderStatus {
    ORDER, CANCEL
}
```

**주문상품 엔티티**
```java
@Entity
@Getter
@Setter
public class OrderItem {
    @Id
    @GeneratedValue
    @Column(name = "order_item_id")
    private Long id;

    // 다대일 관계, 지연로딩 설정
    @ManyToOne(fetch = FetchType.LAZY)
    // 외래키 설정, 연관관계 주인
    @JoinColumn(name = "item_id")
    private Item item;

    // 다대일 관계, 지연로딩 설정
    @ManyToOne(fetch = FetchType.LAZY)
    // 외래키 설정, 연관관계 주인
    @JoinColumn(name = "order_id")
    private Order order;

    // 주문 가격
    private int orderPrice;
    // 주문 수량
    private int count;
}
```

**상품 엔티티**
```java
@Entity
// @Inheritance: 부모클래스에 상속 관계 전략 지정
// InheritanceType.SINGLE_TABLE: 싱글 테이블 전략
@Inheritance(strategy = InheritanceType.SINGLE_TABLE )
// 구분 컬럼명 설정
@DiscriminatorColumn(name = "dtype")
@Getter
@Setter
// 구현체를 가지기 때문에 추상클래스로 작성
public abstract class Item {
    @Id
    @GeneratedValue
    @Column(name = "item_id")
    private Long id;
    private String name;
    private int price;
    private int stockQuantity;

    // 다대다 연관관계
    @ManyToMany(mappedBy = "items")
    private List<Category> categories = new ArrayList<>();
}
```

**상품-도서 엔티티**
```java
@Entity
// dtype 값 지정
@DiscriminatorValue("B")
@Getter
@Setter
public class Book extends Item {
    private String author;
    private String isbn;
}
```

**상품-음반 엔티티**
```java
@Entity
// dtype 값 지정
@DiscriminatorValue("A")
@Getter
@Setter
public class Album extends Item {
    private String artist;
    private String etc;
}
```

**상품-영화 엔티티**
```java
@Entity
// dtype 값 지정
@DiscriminatorValue("M")
@Getter
@Setter
public class Movie extends Item {
    private String director;
    private String actor;
}
```

**배송 엔티티**
```java
@Entity
@Getter
@Setter
public class Delivery {
    @Id
    @GeneratedValue
    @Column(name = "delivery_id")
    private Long id;

    // 일대일 관계, 지연로딩 설정
    @OneToOne(mappedBy = "delivery", fetch = FetchType.LAZY)
    private Order order;

    // 내장 타입
    @Embedded
    private Address address;

    // @Enumerated: Enum 타입 지정
    // EnumType.ORDINAL: Enum 타입 값을 숫자로 지정, 중간에 추가 시 순서가 밀려 장애 발생 가능
    // EnumType.STRING: Enum 타입 값을 문자열로 지정
    @Enumerated(EnumType.STRING)
    // 배송상태 (READY, COMP)
    private DeliveryStatus status;
}
```

**배송상태**
```java
public enum DeliveryStatus {
    READY, COMP
}
```

**카테고리 엔티티**
```java
@Entity
@Getter
@Setter
public class Category {
    @Id
    @GeneratedValue
    @Column(name = "category_id")
    private Long id;

    private String name;

    // 다대다 관계
    @ManyToMany
    // 중간 테이블 매핑
    @JoinTable(name = "category_item",
            // 외래키 설정, 연관관계 주인
            joinColumns = @JoinColumn(name = "category_id"),
            // 반대방향 외래키 설정
            inverseJoinColumns = @JoinColumn(name = "item_id"))
    private List<Item> items = new ArrayList<>();

    // 다대일 관계, 지연로딩 설정
    @ManyToOne(fetch = FetchType.LAZY)
    // 외래키 설정, 연관관계 주인
    @JoinColumn(name = "parent_id")
    private Category parent;

    // 일대다 관계
    @OneToMany(mappedBy = "parent")
    private List<Category> child = new ArrayList<>();

    // 연관관계 편의 메서드
    public void addChildCategory(Category child) {
        this.child.add(child);
        child.setParent(this);
    }
}
```

**주소 값 타입**
```java
// @Embeddable: JPA 내장타입, 어딘가 내장될 수 있음
// @Entity 어노테이션을 작성하지 않아서 테이블로 만들지 않고 pk인 id 필드도 존재하지 않음
@Embeddable
// 값은 변경이 되면 안 돼서 setter를 만들지 않음
@Getter
public class Address {
    private String city;
    private String street;
    private String zipcode;

    // JPA가 리플렉션, 프록시 등의 기술들을 사용하기 위해선 기본 생성자가 있어야 함
    // public으로 만들기보다는 protected로 설정
    protected Address() {

    }

    // 생성시에만 값을 할당
    public Address(String city, String street, String zipcode) {
        this.city = city;
        this.street = street;
        this.zipcode = zipcode;
    }
}

```

### 엔티티 설계시 주의점

- 엔티티에서는 가급적이면 setter를 사용하지 말자
  - 변경 포인트가 많아서 유지보수가 어렵다  
- 모든 연관관계는 지연로딩으로 설정해야 한다
  - 즉시로딩(EAGER): 어떤 엔티티를 조회할 때 연관된 엔티티를 한 번에 조회하는 것  
  - 즉시로딩은 예측이 어렵고 어떤 sql이 실행될지 추적하기가 어렵다, JPQL을 사용할 때 N+1 문제가 자주 발생한다(연관된 모든 테이블 join 쿼리 생성...)  
  - 실무에서 모든 연관관계는 기본적으로 지연로딩(LAZY)으로 설정해야 한다  
  - 연관된 엔티티를 조회하려면 fetch join이나 엔티티 그래프 기능을 사용한다  
  - OneToOne이나 ManyToOne은 기본적으로 fetch 전략이 즉시로딩(EAGER)이 되므로 직접 지연로딩(LAZY)으로 설정해야 한다   
- 컬렉션은 필드에서 초기화하자
  - 컬렉션은 필드에서 초기화하는 것이 안전하다
  - null 문제에서 안전하다
  - 하이버네이트는 persist로 영속화하는 순간 추적하기 위해서 내장 컬렉션으로 변경한다 
  - 가급적이면 컬렉션을 변경하면 안된다
  - 컬렉션을 변경하게 되면 하이버네이트가 원하는 메커니즘으로 동작하지 않을 수 있다

**테이블, 컬럼명 생성 전략**

하이버네이트: 엔티티의 필드명을 그대로 테이블의 컬럼명으로 사용

**casecade = CasecadeType.ALL**

**연관관계 편의 메서드**

## 3. 애플리케이션 구현 준비

### 구현 요구사항

![image](https://user-images.githubusercontent.com/82245973/236528852-bdbbb6ef-e3e0-4055-ae9a-b8c518d7a768.png)  

- 회원 기능
  - 회원 등록, 회원 조회
- 상품 기능
  - 상품 등록, 상품 수정, 상품 조회
- 주문 기능
  - 상품 주문, 주문 내역 조회, 주문 취소

- 예제를 단순화 하기 위해 다음 기능은 구현X
  - 로그인과 권한 관리X
  - 파라미터 검증과 예외 처리X
  - 상품은 도서만 사용
  - 카테고리는 사용X
  - 배송 정보는 사용X

### 애플리케이션 아키텍처

![image](https://user-images.githubusercontent.com/82245973/236528953-91e38197-94dd-4666-bb3a-be70db30c603.png)  

**계층형 아키텍처**

- Controller: 웹 계층
- Service: 핵심 비즈니스 로직, 트랜잭션 처리
- Repository: JPA 직접 사용하고 엔티티 매니저를 사용하여 DB에 접근
- Domain: 엔티티가 모여 있는 계층, 모든 계층에서 사용

**패키지 구조**

- jpabook.jpashop
  - domain
  - exception
  - repository
  - service
  - web

**개발 순서**

서비스, 리포지토리 계층 개발 → 테스트 케이스로 검증 → 웹 계층 개발

## 4. 회원 도메인 개발

### 회원 리포지토리 개발

**회원 리포지토리 코드**

```java
@Repository
@RequiredArgsConstructor
public class MemberRepository {
    // 스프링이 엔티티 매니저를 만들어서 주입해줌
    private final EntityManager em;

    public void save(Member member){
        // 영속성 컨텍스트에 엔티티 객체를 넣음
        // 트랜잭션이 커밋되는 시점에 DB에 반영됨, insert 쿼리 생성
        em.persist(member);
    }

    public Member findOne(Long id){
        // find(엔티티 타입, pk) -> 단건 조회
       return em.find(Member.class, id);
    }

    public List<Member> findAll(){
        // JPQL 작성 -> SQL로 번역
        // SQL: 테이블 대상으로 쿼리를 날림, JPQL: 엔티티 객체를 대상으로 쿼리를 날림
        return em.createQuery("select m from Member m", Member.class)
                .getResultList();
    }

    public List<Member> findByName(String name){
        return em.createQuery("select m from Member m where m.name = :name", Member.class)
                .setParameter("name", name)
                .getResultList();
    }
}
```

### 회원 서비스 개발

**회원 서비스 코드**

```java
@Service
// JPA의 모든 데이터 변경은 트랜잭션 안에서 실행되어야 함
// @Transactional 어노테이션을 클래스 레벨에서 사용하면 public 메서드들은 자동으로 트랜잭션에 들어감
// @Transactional(readOnly = true): 읽기 전용, JPA의 조회 성능을 최적화 함
@Transactional(readOnly = true)
// Lombok - @RequiredArgsConstructor: 모든 final 필드를 가지고 생성자를 만들어줌
@RequiredArgsConstructor
public class MemberService {

    // 스프링이 스프링 빈에 등록된 객체를 자동 주입
    private final MemberRepository memberRepository;

    // 회원 가입
    // @Transactional: 쓰기
    @Transactional
    public Long join(Member member){
        validateDuplicateMember(member);
        memberRepository.save(member);
        return member.getId();
    }

    // 중복 회원 검증 -> 데이터베이스의 unique 제약조건 설정해야 안전
    private void validateDuplicateMember(Member member) {
        List<Member> findMembers = memberRepository.findByName(member.getName());
        if(!findMembers.isEmpty()){
            throw new IllegalStateException("이미 존재하는 회원입니다.");
        }
    }

    // 회원 전체 조회
    public List<Member> findMember(){
        return memberRepository.findAll();
    }

    // 회원 단건 조회
    public Member findOne(Long memberId){
        return memberRepository.findOne(memberId);
    }
}
```

### 회원 기능 테스트

**테스트 요구사항**

- 회원가입을 성공해야 한다
- 회원가입 할 때 같은 이름이 있으면 예외가 발생해야 한다

**회원가입 테스트 코드**

```java
// JUnit 실행시 스프링이랑 엮어서 실행
@RunWith(SpringRunner.class)
// 스프링부트 통합 테스트, 없으면 @Autowired 실패
@SpringBootTest
// @Transactional 어노테이션이 테스트 케이스에 있으면 테스트 종료시 롤백
@Transactional
public class MemberServiceTest {
    @Autowired
    private MemberService memberService;

    @Autowired
    private MemberRepository memberRepository;

    @Test
    public void 회원가입() throws Exception{
        // given
        Member member = new Member();
        member.setName("kim");

        // when
        // 트랜잭션이 commit 될 때 flush가 되면서 JPA 영속성 컨텍스트에 있는 엔티티 객체가 insert 쿼리가 만들어지면서 DB에서 쿼리가 실행됨
        // 그래서 테스트 중에는 롤백되어 insert 쿼리가 실행되지 않음
        Long savedId = memberService.join(member);

        // then
        assertEquals(member, memberRepository.findOne(savedId));
        // 같은 트랜잭션 안에서 같은 pk 값이 같은 엔티티는 같은 영속성 컨텍스트 안에서 하나로 관리됨
    }

    // @Test(expected): 예상되는 예외 작성
    @Test(expected = IllegalStateException.class)
    public void 중복_회원_조회() throws Exception{
        // given
        Member member1 = new Member();
        member1.setName("kim");

        Member member2 = new Member();
        member2.setName("kim");

        // when
        memberService.join(member1);
        // 예외가 발생해야 한다!
        memberService.join(member2);

        // then
        fail("예외가 발생해야 한다.");
    }
}
```

**테스트 케이스를 위한 설정**

운영 환경설정과 테스트 환경설정은 분리시킬 수 있다.

**/src/test/resources/application.yml**

```yml
spring:
  # 데이터베이스 커넥션과 관련된 데이터 소스 설정
  # Hikari CP를 사용해서 커넥션 풀 등을 스프링부트가 알아서 세팅해줌
  datasource:
    # 데이터베이스 접근 url
    # 메모리 모드로 실행
    url: jdbc:h2:mem:test
    username: sa
    password:
    driver-class-name: org.h2.Driver
```

\* 스프링부트는 별도의 DB 설정이 없으면 메모리 모드로 동작한다.

```yml
spring:
# 로깅 설정
logging:
  # 로그 레벨 설정
  level:
    # debug 모드 시 hibernate가 남기는 모든 sql을 볼 수 있음
    # 로거를 통해 출력
    org.hibernate.SQL: debug
    # 쿼리 파라미터 로그 남기기
    org.hibernate.orm.jdbc.bind: trace #스프링 부트 3.x, hibernate6
```

## 5. 상품 도메인 개발

### 상품 엔티티 개발(비즈니스 로직 추가)

### 상품 리포지토리 개발

### 상품 서비스 개발

## 6. 주문 도메인 개발

### 주문, 주문상품 엔티티 개발

### 주문 리포지토리 개발

### 주문 서비스 개발

### 주문 기능 테스트

### 주문 검색 기능 개발

## 7. 웹 계층 개발

### 홈 화면과 레이아웃

### 회원 등록

### 회원 목록 조회

### 상품 등록

### 상품 목록

### 상품 수정

### 변경 감지와 병합(merge)

### 상품 주문

### 주문 목록 검색, 취소

# 참조

- [Inflearn - 실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-%ED%99%9C%EC%9A%A9-1)