---
title: "Spring JPA2"
layout: single
categories: spring
tags: spring
toc: true
toc_label: "Spring JPA2" 
---

# Spring JPA2

멋쟁이사자처럼 대학 11기 백엔드 스프링부트 교육 과정 중 인프런 `실전! 스프링 부트와 JPA 활용2 - API 개발과 성능 최적화`를 수강하고 정리한 포스트입니다.

## 1. API 개발 기본

요즘 화면을 템플릿 엔진으로 만드는 경우도 있지만 그것보다는 vue.js, react.js를 이용해서 SPA로 많이 개발하기 때문에 서버 개발자 입장에서는 프론트엔드나 앱개발자 또는 MSA로 바뀌어가면서 API로 통신해야할 일들이 많아져서 API를 잘 설계하고 개발하는게 중요하다. 

SQL을 사용하여 API를 쓰는게 아니라 JPA를 사용하면 엔티티라는 개념에서 API를 만드는건 다른 차원의 이야기이다.  

[https://www.postman.com/downloads/](https://www.postman.com/downloads/)에서 REST API 테스트 도구인 postman을 설치하자.

### 회원 등록 API

**V1 엔티티를 Request Body에 직접 매핑**

```java
// @RestController = @Controller + @ResponseBody
// @ResponseBody: json이나 xml 데이터를 바로 보냄
@RestController
@RequiredArgsConstructor
public class MemberApiController {
    private final MemberService memberService;

    // 첫 번째 버전
    @PostMapping("/api/v1/members")
    // @RequestBody: json으로 온 http 요청의 body를 매개변수에 매핑해줌
    public CreateMemberResponse saveMemberV1(@RequestBody @Valid Member member){
        Long id = memberService.join(member);
        return new CreateMemberResponse(id);
    }

    @Data
    // 정적 내부 클래스
    static class CreateMemberResponse{
        private Long id;

        public CreateMemberResponse(Long id) {
            this.id = id;
        }
    }
}
```

다음과 같이 `POST` 요청을 `/api/v1/members`로 json 데이터와 함께 날리면 API 응답을 받을 수 있다.

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/144adff2-8303-4b66-b32e-4669de2faf44)  

name을 안넣어도 저장이 된다. 왜냐하면 엔티티에 제약조건이 달려있지 않아서 @Valid 어노테이션이 그냥 지나가기 때문이다.  

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/10db262b-7b1e-4e36-8f2a-29cf4070f8e4)  

검증을 하고 싶다면 엔티티에 @NotEmpty 제약 조건을 넣어주면 된다.  

```java
@Entity
@Getter
@Setter
public class Member {
    @Id
    @GeneratedValue
    // 컬럼명 설정
    @Column(name = "member_id")
    private Long id;

    // @NotEmpty: 필수, 값이 없으면 안됨
    @NotEmpty
    private String name;

    // @Embedded: 내장 타입을 포함함
    @Embedded
    private Address address;

    // 일대다 관계
    // 양방향 연관관계, order 테이블에 있는 member 필드에 의해서 매핑됨
    @OneToMany(mappedBy = "member")
    private List<Order> orders = new ArrayList<>();
}
```

이후 비어있는 json을 전달하게 되면 @Valid 어노테이션이 입력받은 member를 검증해서 오류를 알려준다.  
스프링부트가 기본으로 에러에 대해서 설정해 놓은 스타일로 에러를 응답한다.

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/d3ea9b59-26d3-4137-b46f-9f7727940c33)   

> < v1의 문제 >  
- 화면과 관련된 프레젠테이션 계층의 검증 로직이 엔티티에 들어가 있다.  
하지만 API마다 검증 로직이 다를 수 있고 엔티티가 바뀔경우 API 스펙이 바뀌어버린다.  

따라서 엔티티를 파라미터로 받지 말고 API의 요청 스펙에 맞춰 별도의 DTO를 만들어서 받아야한다.  

**V2 엔티티 대신에 DTO를 RequestBody에 매핑**

```java
// @RestController = @Controller + @ResponseBody
// @ResponseBody: json이나 xml 데이터를 바로 보냄
@RestController
@RequiredArgsConstructor
public class MemberApiController {
    private final MemberService memberService;

    // 두 번째 버전
    @PostMapping("/api/v2/members")
    // 파라미터로 CreateMemberRequest 라는 별도의 DTO 사용
    public CreateMemberResponse saveMemberV2(@RequestBody @Valid CreateMemberRequest request){
        Member member = new Member();
        member.setName(request.getName());

        Long id = memberService.join(member);
        return new CreateMemberResponse(id);
    }

    @Data
    // DTO 클래스
    static class CreateMemberRequest{
        // 검증 로직
        @NotEmpty
        private String name;
    }
}
```

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/17dba48c-d7e1-40c0-9df8-2d5fba70ad1e)  

> < v2의 장점 >  
- 엔티티를 파라미터로 사용하면 정확히 어떤 값들이 넘어오는지 모르지만 별도의 DTO로 만들어서 파라미터로 받게되면 API 스펙이 정리되고 검증도 API 스펙에 맞게 구현할 수 있게된다.   
- 엔티티와 API 스펙을 명확히 분리할 수 있고 엔티티가 변경되어도 API 스펙이 변하지 않는다.  

따라서 API를 만들 때, 엔티티를 외부에 노출하지않고 API 스펙에 맞는 별도의 DTO를 만드는게 정석이다. 

### 회원 수정 API

```java
// @RestController = @Controller + @ResponseBody
// @ResponseBody: json이나 xml 데이터를 바로 보냄
@RestController
@RequiredArgsConstructor
public class MemberApiController {
    private final MemberService memberService;

    @PutMapping("/api/v2/members/{id}")
    // 등록이랑 수정은 API 스펙이 달라서 별도의 DTO 사용
    public UpdateMemberResponse updateMemberV2(@PathVariable("id") Long id,
                                               @RequestBody @Valid UpdateMemberRequest request){
        // 커맨드와 쿼리의 분리
        memberService.update(id, request.getName());
        Member findMember = memberService.findOne(id);
        return new UpdateMemberResponse(findMember.getId(), findMember.getName());
    }

    @Data
    // 업데이트 요청 DTO
    static class UpdateMemberRequest{
        private String name;
    }

    @Data
    @AllArgsConstructor
    // 업데이트 응답 DTO
    static class UpdateMemberResponse{
        private Long id;
        private String name;
    }
}
```

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/2e3d2825-2abc-451f-9fd1-74cd20f6e2e1)  

회원 등록을 하고 회원 수정 API를 호출하게 되면 회원이름이 변경된 것을 확인할 수 있다.

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/561e7982-f34b-4e35-a1b6-3d853dc58efa)  

### 회원 조회 API

단순 조회 기능이어서 테이블을 변경할 이유가 없으므로 application.yml 파일을 수정하자.  
ddl-auto를 none으로 설정하면 데이터를 한번 넣어두면 계속 사용이 가능하다.  

```yml
spring:
  jpa:
    hibernate:
      # create: 애플리케이션 실행 시점에 테이블을 지우고 다시 생성
      # none: 데이터베이스의 정보가 유지됨
      ddl-auto: none
```

이후 MVC로 만들어둔 화면을 통해서 데이터들을 집어넣자.    

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/f86cada8-e215-4549-b7e3-9debfbc14dd8)  

**회원조회 V1: 응답 값으로 엔티티를 직접 외부에 노출**

```java
@RestController
@RequiredArgsConstructor
public class MemberApiController {
    private final MemberService memberService;

    @GetMapping("api/v1/members")
    public List<Member> membersV1(){
        return memberService.findMembers();
    }
}
```

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/aafbb332-3615-4b8b-b32b-f8cd0164bbc2)  


> < v1의 문제 >  
- 엔티티를 파라미터나 반환값으로 전달하게되면 해당 API에서 원하지 않는 정보가 같이 전달되고 엔티티의 있는 모든 정보들이 외부에 다 노출되게 된다. @JsonIgnore 어노테이션으로 제외시킬 수 있지만 만약 다른 API에서 사용하는 필드라면 문제가 발생하고 엔티티 안에 프레젠테이션 계층을 위한 로직이 추가되어버린다.  
- 엔티티의 필드명이 바뀌면 클라이언트에게 변경된 필드명으로 값이 전달되어 API 스펙이 변경되어 버린다.  
- 리스트 값을 감싸지 않고 반환하면 API 스펙이 변경될때, 추가적인 데이터를 넣기 힘들어 유연성이 떨어진다.  



**회원조회 V2: 응답 값으로 엔티티가 아닌 별도의 DTO 사용**

```java
@RestController
@RequiredArgsConstructor
public class MemberApiController {
    private final MemberService memberService;

    @GetMapping("api/v2/members")
    public Result membersV2(){
        List<Member> findMembers = memberService.findMembers();
        List<MemberDto> collect = findMembers.stream()
                .map(m -> new MemberDto(m.getName()))
                .collect(Collectors.toList());
        // List를 바로 반환하면 json의 배열타입으로 반환이 되므로 Result로 감싸줌
        return new Result(collect);
    }

    @Data
    @AllArgsConstructor
    // 데이터를 감싸는 객체
    // 추가 필드가 생겨도 변경이 쉬움
    static class Result<T>{
        private T data;
    }

    @Data
    @AllArgsConstructor
    // 외부에 노출할 것만 DTO에 저장
    // API 스펙 == DTO 코드
    static class MemberDto{
        private String name;
    }
}
```

다음과 같이 data 안에 dto 배열이 들어있는 것을 확인할 수 있다.

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/2135b9e6-a949-4781-a5fd-2d21319c3d17)  

절대 엔티티를 외부에 노출하거나 직접 반환하지 말고 항상 DTO로 바꿔서 반환해야 한다.  



## 2. API 개발 고급 - 준비

### 조회용 샘플 데이터 입력

API 개발 고급 설명을 위한 샘플용 주문 데이터를 입력하자.

- userA
    - JPA1 BOOK
    - JPA2 BOOK
- userB
    - SPRING1 BOOK
    - SPRING2 BOOK

```java
/*
    총 주문 2개
    - userA
        - JPA1 BOOK
        - JPA2 BOOK
    - userB
        - SPRING1 BOOK
        - SPRING2 BOOK
*/

// @Component: 스프링의 ComponentScan의 대상이 됨
@Component
@RequiredArgsConstructor
public class InitDb {
    private final InitService initService;

    // @PostConstruct: 스프링 빈에 DI 작업이 끝나면 초기화 작업을 위해 스프링이 호출해줌
    @PostConstruct
    public void init(){
        initService.dbInit1();
        initService.dbInit2();
    }

    @Component
    @Transactional
    @RequiredArgsConstructor
    static class InitService {
        private final EntityManager em;

        public void dbInit1() {
            Member member = createMember("userA", "seoul", "asdf", "1234");
            em.persist(member);

            Book book1 = createBook("JPA1 BOOK", 10000, 100);
            em.persist(book1);

            Book book2 = createBook("JPA2 BOOK", 20000, 100);
            em.persist(book2);

            Delivery delivery = createDelivery(member);

            OrderItem orderItem1 = OrderItem.createOrderItem(book1, 10000, 1);
            OrderItem orderItem2 = OrderItem.createOrderItem(book2, 20000, 2);
            Order order = Order.createOrder(member, delivery, orderItem1, orderItem2);

            em.persist(order);
        }

        public void dbInit2() {
            Member member = createMember("userB", "yong-in", "qwer", "5678");
            em.persist(member);

            Book book1 = createBook("SPRING1 BOOK", 20000, 200);
            em.persist(book1);

            Book book2 = createBook("SPRING2 BOOK", 40000, 300);
            em.persist(book2);

            Delivery delivery = createDelivery(member);

            OrderItem orderItem1 = OrderItem.createOrderItem(book1, 20000, 3);
            OrderItem orderItem2 = OrderItem.createOrderItem(book2, 40000, 4);
            Order order = Order.createOrder(member, delivery, orderItem1, orderItem2);
            em.persist(order);
        }

        private Member createMember(String name, String city, String street,
                                    String zipcode) {
            Member member = new Member();
            member.setName(name);
            member.setAddress(new Address(city, street, zipcode));
            return member;
        }

        private Book createBook(String name, int price, int stockQuantity) {
            Book book = new Book();
            book.setName(name);
            book.setPrice(price);
            book.setStockQuantity(stockQuantity);
            return book;
        }

        private Delivery createDelivery(Member member) {
            Delivery delivery = new Delivery();
            delivery.setAddress(member.getAddress());
            return delivery;
        }
    }
}
```

## 3. API 개발 고급 - 지연 로딩과 조회 성능 최적화

주문 + 배송정보 + 회원을 조회하는 API 개발

지연로딩 때문에 발생하는 성능문제의 단계적 해결

### 간단한 주문 조회 V1: 엔티티를 직접 노출

```java
/*
    OneToOne, ManyToOne 관계 최적화
    Order
    Order -> Member
    Order -> Delivery
 */
@RestController
@RequiredArgsConstructor
public class OrderSimpleApiController {
    private final OrderRepository orderRepository;

    @GetMapping("/api/v1/simple-orders")
    public List<Order> ordersV1(){
        List<Order> all = orderRepository.findAllByString(new OrderSearch());
        // 양방향 연관관계에서 문제 발생! order가 member를 부르고 member가 order를 부름, 무한루프...
        // Order를 참조하는 엔티티의 필드에 @JsonIgnore 어노테이션을 작성해야함
        return all;
    }
}
```

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/de832af2-d65e-4116-a236-ed098edc3f9e)  

하지만 요청이 가지 않는다. 양방향 연관관계인 필드가 서로를 참조해서 무한루프에 걸렸기 때문이다.  

그래서 양방향 연관관계인 필드들에 다 @JsonIgnore 어노테이션을 작성해줘야 한다.  

```java
public class Member {
    // @JsonIgnore: json으로 반환할 때 무시함
    @JsonIgnore
    private List<Order> orders = new ArrayList<>();
}

public class OrderItem {
    @JsonIgnore
    private Order order;
}

public class Delivery {
    @JsonIgnore
    private Order order;
}
```
여기선 Order를 참조하는 Member, OrderItem, Delivery 엔티티에 작성해줬다.  

그런데 다시 요청을 보내면 다음과 같은 에러가 발생한다.  

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/1b8cca1d-830e-43fa-a682-705c66117def)  

지연로딩인 필드들은 DB에 쿼리를 날려서 가져오지 않고 Hibernate가 프록시 객체(ByteBuddyInterceptor)를 생성해서 넣어주고 나중에 지연로딩인 필드에 직접 접근할 때 DB에 접근해서 값을 가져와 채워준다.(프록시 초기화라고 한다)  

jackson 라이브러리가 프록시 객체를 처리할 수 없어서 에러가 발생했는데  
이를 처리해주는 `hibernate5module` 라이브러리를 추가해주자.  

```gradle
// 지연로딩 필드(프록시 객체)에 대해 json에서 제외해줌
implementation 'com.fasterxml.jackson.datatype:jackson-datatype-hibernate5-jakarta'
```

라이브러리를 추가했으면 스프링 빈에 hibernate5module을 등록하자.  

```java
// 스프링 빈에 Hibernate5JakartaModule 등록
@Bean
Hibernate5JakartaModule hibernate5JakartaModule(){
    return new Hibernate5JakartaModule();
}
```

그러면 다음과 같이 요청이 성공한 걸 볼 수 있다.  

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/89dc5c58-c8ab-4cda-be2f-1377345b534b)  

지연로딩은 아직 DB에서 조회한게 아니기 때문에 jackson이 json으로 전달할 때 hibernate5module이 다 무시하도록 되어있어서 null로 반환한다.  

**강제 Lazy 로딩 방법 1**

다음과 같이 설정하면 지연로딩인 필드를 전부 가져올 수 있다.

```java
// 스프링 빈에 Hibernate5JakartaModule 등록
@Bean
Hibernate5JakartaModule hibernate5JakartaModule(){
    Hibernate5JakartaModule hibernate5JakartaModule = new Hibernate5JakartaModule();
    // json 생성하는 시점에 강제 Lazy 로딩
    hibernate5JakartaModule.configure(Hibernate5JakartaModule.Feature.FORCE_LAZY_LOADING, true);
    return hibernate5JakartaModule;
}
```

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/dc6f50f5-e25f-408e-a1cf-7e6070540055)  

이렇게 엔티티를 그대로 노출하게 되면 엔티티가 변경되면 API 스펙이 다 바뀌게 된다.  

그리고 API 스펙상 필요없는 orderItem 필드도 가져와서 필요없는 쿼리가 다 날라가게되서 성능상 문제가 발생한다.  

**강제 Lazy 로딩 방법 2** 

엔티티를 모두 노출시키지않고 원하는 필드만 노출시킬 수 있다.  

hibernate5module의 `FORCE_LAZY_LOADING` 옵션을 주석처리하고 다음 코드를 작성하자.  

```java
@RestController
@RequiredArgsConstructor
public class OrderSimpleApiController {
    private final OrderRepository orderRepository;

    @GetMapping("/api/v1/simple-orders")
    public List<Order> ordersV1(){
        List<Order> all = orderRepository.findAllByString(new OrderSearch());

        // 강제 Lazy 로딩
        for (Order order : all) {
            // 프록시객체를 가져올 때는 DB에 쿼리가 날라가지 않음
            // 프록시객체.getter() -> JPA가 쿼리를 날려서 실제 값을 가져옴
            order.getMember().getName();        // Member Lazy 강제 초기화
            order.getDelivery().getAddress();   // Delivery Lazy 강제 초기화
        }

        // 양방향 연관관계에서 문제 발생! order가 member를 부르고 member가 order를 부름, 무한루프...
        // Order를 참조하는 엔티티의 필드에 @JsonIgnore 어노테이션을 작성해야함
        return all;
    }
}
```

그러면 다음과 같이 내가 원하는 member와 delivery 필드만 가져온 것을 볼 수 있다.

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/caddfd2e-d8b4-4c53-b928-8063d7ae52d7)  


> 주의!  
지연로딩(LAZY)을 피하기 위해 즉시로딩(EARGR)으로 설정하면 안된다.  
JPQL로 조회만 하여도 나머지가 EAGER로 설정되어있으면 모두 쿼리를 다 날려서 N+1 문제가 발생할 수 있고 다른 API에서 필요없는 정보를 항상 가져오기 때문에 성능 최적화를 할 수 있는 여지가 없어진다.  

### 간단한 주문 조회 V2: 엔티티를 DTO로 변환

```java
@RestController
@RequiredArgsConstructor
public class OrderSimpleApiController {
    private final OrderRepository orderRepository;

    @GetMapping("/api/v2/simple-orders")
    public List<SimpleOrderDto> ordersV2(){
        // N+1의 문제 -> 1번째 쿼리의 결과로 N번의 쿼리가 추가 실행되는 문제
        // 영속성 컨텍스트에 엔티티가 있는 경우에는 쿼리를 생략할 수 있음
        List<Order> orders = orderRepository.findAllByString(new OrderSearch());
        List<SimpleOrderDto> result = orders.stream()
                // DTO로 변환되면서 LAZY 초기화 발생
                .map(o -> new SimpleOrderDto(o))
                .collect(Collectors.toList());
        return result;
    }

    @Data
    // API 스펙을 명확히 정의
    static class SimpleOrderDto{
        private Long orderId;
        private String name;
        private LocalDateTime orderDate;
        private OrderStatus orderStatus;
        private Address address;

        public SimpleOrderDto(Order order){
            this.orderId = order.getId();
            this.name = order.getMember().getName();    // LAZY 초기화: 영속성 컨텍스트가 id 값으로 찾고 없으면 db쿼리 날림
            this.orderDate = order.getOrderDate();
            this.orderStatus = order.getStatus();
            this.address = order.getDelivery().getAddress();    // LAZY 초기화
        }
    }
}
```

다음과 같이 엔티티가 dto로 변환되어 반환된 것을 볼 수 있다.  

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/4925b3cd-900a-4acb-8ef6-170846b9d415)  

하지만 v1과 v2 모두 공통적인 문제가 있는데 LAZY 로딩으로 인한 데이터베이스 쿼리가 너무 많이 생겨버린다는 것이다.  

먼저 ORDER를 조회한 다음에 MEMBER와 DELIVERY도 조회하기 때문에 ORDER 조회 결과 하나당 MEMBER, DELIVERY를 한 번 조회해서 ORDER(1) + MEMBER(2) + DELIVERY(2) = 총 5번의 쿼리가 생성된다.  
만약 영속성 컨텍스트에 엔티티가 있다면 쿼리 생략이 가능하다.  

이런 지연로딩의 문제는 패치조인을 통해 최적화할 수 있다.

### 간단한 주문 조회 V3: 엔티티를 DTO로 변환 - 페치 조인 최적화

```java
@RestController
@RequiredArgsConstructor
public class OrderSimpleApiController {
    private final OrderRepository orderRepository;

    @GetMapping("/api/v3/simple-orders")
    public List<SimpleOrderDto> ordersV3(){
        // 패치조인을 이용한 N+1 문제 해결
        List<Order> orders =  orderRepository.findAllWithMemberDelivery();
        List<SimpleOrderDto> result = orders.stream()
                .map(SimpleOrderDto::new)
                .collect(Collectors.toList());
        return result;
    }
}
```

```java
@Repository
// Lombok: final 필드 생성자
@RequiredArgsConstructor
public class OrderRepository {
    // 엔티티 매니저 주입
    private final EntityManager em;

    // 패치조인 활용
    public List<Order> findAllWithMemberDelivery() {
        // order를 가져올 때 한번에 member와 delivery도 가져옴 (join과 동시에 select)
        // LAZY 옵션을 다 무시하고 값을 다 채워서 가져옴
        return em.createQuery("select o from Order o " +
                "join fetch o.member m " +
                "join fetch o.delivery d ", Order.class)
                .getResultList();
    }
}
```

실무에서 JPA의 성능 문제의 90%는 N+1 문제이다.  
기본적으로 LAZY로 깔고 필요한 것만 패치조인으로 DB에서 한방에 가져오면 대부분의 성능문제가 해결된다.  

다음과 같이 v2와 v3는 결과적으로 같지만 쿼리가 다르다.  

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/5acf54d1-ca6b-459b-9b71-8ef360717c44)

![image](https://github.com/kws9208/kws9208.github.io/assets/82245973/34784d38-9e8e-453a-a824-9857973e11e2)  

v2는 쿼리가 5번 실행되지만 v3는 쿼리가 한 번만 실행된다!  

fetch join을 통해 쿼리 한 번에 다 들고와서 LAZY 로딩 자체가 일어나지 않는다.  

### 간단한 주문 조회 V4: JPA에서 DTO로 바로 조회

```java
@RestController
@RequiredArgsConstructor
public class OrderSimpleApiController {
    private final OrderRepository orderRepository;
    private final OrderSimpleQueryRepository orderSimpleQueryRepository;

    @GetMapping("/api/v4/simple-orders")
    public List<OrderSimpleQueryDto> ordersV4(){
        // 엔티티를 조회해서 엔티티를 DTO로 변환하지 않고
        // JPA에서 DTO로 바로 조회
        return orderSimpleQueryRepository.findOrderDtos();
    }
}
```

```java
@Repository
@RequiredArgsConstructor
// 성능 최적화를 위한 쿼리용 리포지토리
// 리포지토리는 순수한 엔티티를 조회하는데 쓰임
// 화면에 의존적인 로직은 리포지토리와 분리
public class OrderSimpleQueryRepository {
    private final EntityManager em;

    public List<OrderSimpleQueryDto> findOrderDtos() {
        // DTO로 반환하기 위해선 new 연산자을 써야함
        return em.createQuery("select new jpabook.jpashop.repository.order.simplequery.OrderSimpleQueryDto(o.id, m.name, o.orderDate, o.status, d.address) " +
                        "from Order o " +
                        "join o.member m " +
                        "join o.delivery d", OrderSimpleQueryDto.class)
                .getResultList();
    }
}
```

```java
@Data
// 컨트롤러에서 DTO를 정의하면 리포지토리에서 컨트롤러를 의존하게 됨
// 리포지토리에서 컨트롤러로 의존가능성을 없애기 위해 외부 클래스로 정의
public class OrderSimpleQueryDto {
    private Long orderId;
    private String name;
    private LocalDateTime orderDate;
    private OrderStatus orderStatus;
    private Address address;

    public OrderSimpleQueryDto(Long orderId, String name, LocalDateTime orderDate, OrderStatus orderStatus, Address address){
        this.orderId = orderId;
        this.name = name;    // LAZY 초기화: 영속성 컨텍스트가 id 값으로 찾고 없으면 db쿼리 날림
        this.orderDate = orderDate;
        this.orderStatus = orderStatus;
        this.address = address;    // LAZY 초기화
    }
}
```

v4는 진짜 필요한 것들만 join으로 select해서 가져온다.  

하지만 v3와 v4는 각자 장단점이 있어 어느게 더 좋다고 우열을 가리기 힘들다.  

> v3는 fetch join으로 원하는 것만 select 한 것이다. 엔티티를 가져와 비즈니스 로직에서 사용해서 데이터를 변경할 수 있고 다양한 API에서 원하는 DTO로 변환하여 사용이 가능하다.  

> v4는 원하는 것만 쿼리문을 통해 DTO로 가져온 것이다. 엔티티가 아니라 DTO로 가져와서 데이터를 변경할 수 없고 해당 API에서만 사용이 가능해 재활용이 불가능하다. 그리고 리포지토리에 API 스펙에 맞춘 코드가 들어가게되어 논리적인 계층이 깨지고 화면에 의존적이게 된다. 그래서 API 스펙이 바뀌면 리포지토리도 바꿔야한다. 하지만 v3보다 조금 더 성능 최적화 면에서 낫다.

\* select 문은 성능에 큰 영향을 미치지 않고 from 절의 join이나 where 절의 조건들 때문에 성능 문제가 생긴다. 
API의 트래픽이 크고 조회할 필드들이 너무 많을 때는 최적화를 고려를 해봐야한다.  

**쿼리 방식 선택 권장 순서**
1. 우선 엔티티로 DTO로 변환하는 방법을 선택한다.(v2)  
2. 필요하면 fetch join으로 성능을 최적화한다.(v3) → 대부분의 성능 문제가 해결된다.  
3. 그래도 안되면 DTO로 직접 조회한다.(v4)
4. 최후의 방법으로 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해서 SQL을 직접
사용한다.  

## 4. API 개발 고급 - 컬렉션 조회 최적화

### 주문 조회 V1: 엔티티 직접 노출

### 주문 조회 V2: 엔티티를 DTO로 변환

### 주문 조회 V3: 엔티티를 DTO로 변환 - 페치 조인 최적화

### 주문 조회 V3.1: 엔티티를 DTO로 변환 - 페이징과 한계 돌파

### 주문 조회 V4: JPA에서 DTO 직접 조회

### 주문 조회 V5: JPA에서 DTO 직접 조회 - 컬렉션 조회 최적화

### 주문 조회 V6: JPA에서 DTO로 직접 조회, 플랫 데이터 최적화

## 5. API 개발 고급 - 실무 필수 최적화

### OSIV와 성능 최적화